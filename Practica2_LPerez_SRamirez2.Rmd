---
title: 'Práctica 2: Limpieza y validación de los datos'
author: "Luis Manuel Pérez Geraldino y Sergi Ramirez Mitjans"
date: "16 de Maig de 2019"
output:
  pdf_document: default
header-includes:
- \usepackage[spanish]{babel}
- \usepackage{longtable}
- \usepackage{color}
- \usepackage{float}
- \usepackage{ltxtable}
- \usepackage{tabularx}
- \usepackage{fancyhdr}
- \usepackage[font=small,labelfont=bf]{caption}
---

```{r, eval = FALSE, echo = FALSE}
# Instalar paquetes de R que necesitaremos
RequiredPackages <- c("Hmisc", "dplyr", 'VIM', 'FactoMineR', 'tidyr', 'dplyr', 
                      'magrittr', 'plspm', 'amap')
for (i in RequiredPackages) { #Installs packages if not yet installed
    if (!require(i)) install.packages(i)
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    cache       = TRUE,     # if TRUE knitr will cache the results to reuse in future knits
    fig.width   = 10,       # the width for plots created by code chunk
    fig.height  = 10,       # the height for plots created by code chunk
    fig.align   = 'center', # how to align graphics in the final doc. 'left', 'right', 'center'
  # fig.path    = 'figs/',  # file path to the directory where knitr shall store the graphics files
    results     = 'asis',   # knitr will pass through results without reformatting them
    echo        = TRUE,     # in FALSE knitr will not display code in the code chunk above it's results
    message     = TRUE,     # if FALSE knitr will not display any messages generated by code
    strip.white = TRUE,     # if FALSE knitr will not remove white spaces at the beg or end of code chunk
    warning     = TRUE,     # if FALSE knitr will not display any warning messages in the final document
    comment     = FALSE)    
```

```{r results='asis', echo = FALSE, comment= FALSE}
options(warn=-1)
options(scipen=999)
options(tinytex.verbose = TRUE)
```

# 1. Descripción del dataset

El dataset que a continuación se va a describir, se a obtenido mediante *web scrapping* en la práctica 1 de esta misma asignatura por lo tanto está práctica se tratará de realizar la limpieza del dataset que se consiguió desarrollar en etapas anteriores de esta asignatura. 

El conjunto de datos obtenido recoge los medicamentos con más facturación en el mundo farmacéutico. A la vez también esta incorporado los medicamentos más consumidos en España. Este dataset es variable ya que se tendrán tantos medicamentos como el código demande. Esto es posible ya que el código esta preparado para hacer de buscador y extractor de aquellos medicamentos que se pasen por parámetros. Algunas variables de las que encontramos en el dataset sería el precio, nombre del medicamente, genérico o url del Vademecum.

```{r, message=TRUE, warning=TRUE}
# Leemos los datos para guardar
datos <- read.csv2('result.csv',  sep = ";", header = T, stringsAsFactors = T, dec = ".", encoding = 'latin1')

# Cambiamos el nombre de las columnas para que puedan ser leibles
cols <- c("Medicamento", "URL", "Presentacion", "Codigo_Nacional", "Tipo", "Generico", "Laboratorio", "Estado", "Fecha_Alta", "Fecha_Baja", "Aportacion_Beneficiario", "Principio_Activo", "PVP", "Precio_Referencia", "Menor_Precio_Agrupacion_Homogenea", "Agrupacion_Homogenea", "Diagnostico_Hospitalario", "Tratamiento_Larga_Duracion", "Control_Medico", "Huerfano", "Enfermedad")
colnames(datos) <- cols
```


A continuación se explicará el significado de cada variable: 

```{r results='asis', echo = FALSE, comment= FALSE, fig.align="left"}
library(readxl)
library(xtable)
archivos <- 'codbook_variables.xlsx'
codbook_vademecum <- data.frame(read_excel(archivos, sheet = 1))
codbook <- data.frame(read_excel(archivos, sheet = 2))
codbook <- rbind(codbook_vademecum, codbook)
codbook <- xtable(codbook, include.rownames=FALSE)
align(codbook) <- "|l|l|l|X|"
print(codbook, tabular.environment="tabularx", width="\\textwidth", comment = FALSE)
```


## 2. Objetivos

La creación del estudio de nuestra base de datos contiene diferentes objetivos. A continuación vamos a explicar cada uno de ellos para que tenga sentido el echo de realizar según que prueba estadística o modelo de predicción. Los objetivos son los siguientes:
  
  - Para empezar queremos realizar un estudio para saber si existe o no existe diferencia entre el precio y los grupos tipo de medicamento.
  
  - También queremos hacer un estudio para encontrar existencia diferencias en el precio según el laboratorio que realiza el medicamento. 
  
  - Mirar si existe diferencias de precio según la enfermedad que se quiera tratar. 
  
  - Agrupar conjunto de medicamentos para detectar patrones subjacentes detrás de ello. 
  
  - Intentar hacer una predicción del precio. Este apartado consistirá en realizar un modelo de predicción de precio. Nos servirá a las farmacéuticas para facilitarles el precio que se le debe de asignar a un enfermo según variables del medicamento que va a utilizar. 
  
  - Realizar una clasificación de la enfermedad según variables económica y del laboratorio que lo fabrica. Al final queremos hacer este estudio para poder ayudar a las empresas aseguradoras para renovar o no un seguro de salud sabiendo el gasto en medicamentos que realiza el cliente saber que enfermedad tiene. 
  
# 3. Análisis Descriptivo

A continuación vamos a hacer un descriptivo numérico de como son nuestras variables. 

```{r}
# Generamos 3 vectores con la posicion de las columnas según la tipologia de ellas
lista_clase <- sapply(datos, class)

# Generamos diferentes variables
var_factor    <- unname(which(lista_clase %in% c('factor', 'character')))
var_numeric   <- unname(which(lista_clase %in% c('numeric', 'integer')))

# Creamos una función para que nos generen los gráficos y descriptivos univariante de los datos.
descriptivoUnivariante <- function(variables, dataframe){
  # Nos quedamos con el nombre de todas las variables
	## Hacemos un bucle para cada una de ellas
	for (variable in variables) {
		if (class(valores) %in% c('factor', 'character')){
			# Generamos la tabla para las variables categoricas
			frecs <- round(table(valores)/sum(table(valores)), 2)
			print(frecs)
			counts <- data.frame(table(valores))
			grafico <- barplot(frecs, main = paste0("Barplot de la variable ", variable), 
			                   xlab = "",     col = "darkblue", ylim = c(0, 1))
			text(x = grafico, y = frecs, label = counts$Freq, pos = 3, cex = 1)
		}
	}
}
```


## 3.1 Variables numéricas

```{r}
cols <- colnames(datos)[var_numeric]
cols <- cols[which(!cols %in% c('Codigo_Nacional'))]
library(pastecs)
tabla <- round(stat.desc(datos[, cols]), 2)
tabla <- xtable(tabla, include.rownames=FALSE)
print(tabla, tabular.environment="longtable", width="\\textwidth", comment = FALSE)

par(mfrow = c(1, 3))
for(col in cols){
  			grafico <- boxplot(datos[, col], col = "steelblue2", main = col)
}
par(mfrow = c(1, 1))
```

## 3.2 Varibles categóricas
```{r}
cols <- colnames(datos)[var_factor]
cols2 <- c('Presentacion', 'Laboratorio', 'Principio_Activo')
cols <- cols[which(!cols %in% c('Codigo_Nacional', 'Medicamento', 'URL', 'Fecha_Alta', 'Fecha_Baja', 'Agrupacion_Homogenea', 'Diagnostico_Hospitalario', 'Control_Medico', 'Huerfano', cols2))]
descriptivoUnivariante(cols, datos)
```


# 4. Análisis Descriptivo Bivariante

## 4.1 Con la variable respuesta precio
### 4.1.1 Variables numéricas

```{r}
library(xtable)
cols <- c("PVP", "Precio_Referencia", "Menor_Precio_Agrupacion_Homogenea")
correlaciones <- cor(datos[, cols], use = "complete.obs")
tabla <- xtable(correlaciones, include.rownames=FALSE)
print(tabla, tabular.environment="longtable", width="\\textwidth", comment = FALSE)
```

Por lo tanto del output podemos extraer la información de que las tres variables numéricas tienen una correlación perfecta (1) y por lo tanto podemos eliminar de nuestros datos 2 de ellas. 

Eliminaremos las variables `Precio_Referencia` y `Menor_Precio_Agrupacion_Homogenea` ya que no tiene sentido que posteriormente se haya de imputar estos valores para que nos quede igual que la variable `PVP`. Por lo tanto no hará tampoco falta imputación de datos faltantes en las variables numéricas. 


### 4.1.2 Variables categóricas

Para realizar dichas pruebas, haremos el contraste de Kruskal-Wallis para detectar independencia entre grupos y las graficaremos con boxplots múltiples.

```{r}
kruskal.test(PVP ~ Enfermedad , data = datos)
```

# 5. Limpieza de los datos
## 5.1 Creación de nuevas variables

Primero de todo vamos a discretizar la variable `PVP`. 

Aunque sabemos que la discretización de una variable numérica hace que dejes de tener información de la distribución de la variable numérica, para representaciones posteriores necesitamos tener la variable `PVP` discretizada para poder representarla por ello vamos a crear la a continuación. 

Cuando hablamos de discretizar una variable, se define como el remplazar variables numéricas a atributos categóricos con etiquetas. 

Para realizar la discretización vamos a realizar métodos de clustering. Este tipo de modelo k-means consiste en buscar aquellas clases que sean homogeneas en ellas mismas pero entre ellas sean suficientemente separables.Por lo tanto dividen sus valores en grupos teniendo en cuenta la distribución del atributo y la  cercanía de los datos a cada grupo.

```{r}
library(arules)
# k-means clustering
hist(datos[, 'PVP'], breaks = 20, main = "Clustering")
discretizacion <- discretize(datos[, 'PVP'], method = "cluster", breaks = 2, onlycuts = TRUE)
datos[, 'tram_PVP'] <- cut(datos[, 'PVP'], breaks = discretizacion)
```

Seguidamente creamos una variable llamada `tram_presentacion` donde lo que se hará será agrupar categorias de presentación de tal forma tener menos niveles en la variable. 

```{r}
datos[, 'tram_presentacion'] <- 'envase'

# inhalador
patron <- 'inhalador|inhalación|inh'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'inhalador'

# Capsulas
patron <- 'cap|cápsula|cápsulas'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'capsulas'

# Frasco
patron <- 'frasco'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'frasco'

# blíster
patron <- 'blister|blíster'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'blíster'

# OPA
patron <- 'opa'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'OPA'

# Plumas
patron <- 'pluma'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Plumas'

# Cartuchos
patron <- 'cartuchos'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Cartuchos'

# Vial
patron <- 'vial'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Vial'

# Bote
patron <- 'bote'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Bote'

# Tiras
patron <- 'tiras'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Tiras'

# Sobres
patron <- 'sobres'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Sobres'

# Comprimidos
patron <- 'comp|comprimidos'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Comprimidos'

# Ampollas
patron <- 'ampollas'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Ampollas'

# Jeringas
patron <- 'jeringas'
qui <- grep(patron, tolower(datos[, 'Presentacion']))
datos[qui, 'tram_presentacion'] <- 'Jeringas'
```

Seguidamente, generamos la variable `Baja`. Esta variable es una variable dicotómica extraida de la variable `Fecha_Baja` que nos permitirá saber si el medicamento se ha dado de baja en y por lo tanto no se encuentra ni a la venta ni financiado por el sistema nacional de salud. 

```{r}
# Creamos la variable Baja que consiste en si el medicamento esta o no esta dado de baja
datos[, 'Baja'] <- ifelse(datos[, 'Fecha_Baja'] == "", "NO", "SI")
```

El siguiente paso es generar dos nuevas variables. Estas nuevas variables serán la codificación de las variables `Agrupacion_Homogenea` y `Laboratorio`. Hemos tomado esta decisión ya que queremos evitar que por motivos de escritura de las categorias de la variable encontremos varios laboratorios que se refieren al mismo escrito de forma diferente o varias agrupaciones homogeneas que le sucedan lo mismo. 

```{r}
# Separamos el código de la agrupación
codigos <- strsplit(as.character(datos[, 'Agrupacion_Homogenea']), "-")
data = data.frame(codigo = character(), agrupacion = character(), stringsAsFactors=FALSE)

for (i in 1:length(codigos)){
    if(codigos[i][1] == ""){
      data[i, 1] = NA
      data[i, 2] = NA
    } else {
      data[i, 1] = as.character(codigos[[i]][1])
      data[i, 2] = as.character(codigos[[i]][2])
    }
}

datos[, 'Codigo_Agrupacion'] <- data[, 'codigo']
```

Seguimos con la variable `Laboratorio`.

```{r}
# Realizamos la separación por laboratorio
lab <- strsplit(as.character(datos[, 'Laboratorio']), ",")
data = data.frame(codigo = character(), laboratorio = character(), sociedad =  character(), stringsAsFactors = FALSE)

for (i in 1:length(codigos)){
    if(length(lab[[i]]) == 3){
      valor1 = as.character(lab[[i]][1])
      valor2 = as.character(lab[[i]][2])
      valor3 = as.character(lab[[i]][3])
    } else {
      if (length(lab[[i]]) == 2){
      valor1 = as.character(lab[[i]][1])
      valor2 = as.character(lab[[i]][2])
      valor3 = ""
      } else {
      valor1 = ""
      valor2 = as.character(lab[[i]][2])
      valor3 = ""
      }
    }
    data[i, 1] = valor1
    data[i, 2] = valor2
    data[i, 3] = valor3
}

datos[, 'Codigo_Laboratorio'] <- data[, 'codigo']
```

Antes de eliminar la variable `Laboratorio`, vamos a aprovechar dicha variable para crear una nueva variable que la llamaremos `Sociedad`. Esta nueva variable consiste en identificar cada medicamento de su laboratorio si el laboratorio es de una Sociedad anónima (S.A.), Sociedad anónima unipersonal (S.A.U.), sociedad limitada (S.L.) y sociedad limitada unipersonal (S.L.U.).

```{r}
datos[, 'Sociedad'] <- 'Sin sociedad'

# Sociedad anónima (S.A.)
patron <- 'S.A.|S.A'
qui <- grep(patron, toupper(datos[, 'Laboratorio']))
datos[qui, 'Sociedad'] <- 'S.A.'

# Sociedad anónima unipersonal (S.A.U.)
patron <- 'S.A.U.|S.A.U'
qui <- grep(patron, toupper(datos[, 'Laboratorio']))
datos[qui, 'Sociedad'] <- 'S.A.U.'

# Sociedad limitada (S.L.)
patron <- 'S.L.|S.L'
qui <- grep(patron, toupper(datos[, 'Laboratorio']))
datos[qui, 'Sociedad'] <- 'S.L.'

# Sociedad limitada unipersonal (S.L.U.)
patron <- 'S.L.U.|S.L.U'
qui <- grep(patron, toupper(datos[, 'Laboratorio']))
datos[qui, 'Sociedad'] <- 'S.L.U.'
```


## 5.2 Seleccion de las variables

A continuación se detallará que variables del dataset se descartará y cuales son los motivos que nos hacen descartar las variables. Estas variables son: 
  - `Medicamento`: Es el nombre del medicamento y por lo tanto no lo necesitamos para generar modelos ya que sólo lo necesitamos para identifcar cada registro.
  - `URL`: Es una variable que enlaza cada url del vademecum con el registro del medicamento.
  - `Precio_Referencia`: Descartamos esta variable ya que detectamos que tenian NA's y que era igual que la variable `PVP` al tener correlación de 1.
  - `Fecha_Alta`: Descartamos la variable ya que no trabajaremos con fechas de introducción de la información en la base de datos ya que no nos aporta información. 
  - `Fecha_Baja`: Descartamos la variable ya que no nos aporta información.
  - `Menor_Precio_Agrupacion_Homogenea`: Descartamos esta variable ya que detectamos que tenian NA's y que era igual que la variable `PVP` al tener correlación de 1.
  - `Generico`: Eliminamos esta variable ya que no tiene información (es toda NA's)
  - `Presentacion`: Escogemos la variable creada `tram_presentacion` en lugar de presentación para evitar tener una variable con muchas categorias. 
  - `Agrupacion_Homogenea`: Escogemos la variable creada `Codigo_Agrupacion` en su defecto para evitar que hayan posible problemas en la unificación de categorias escritas de diferentes formas. 
  - `Laboratorio`:  Escogemos la variable creada `Codigo_Laboratorio` en su defecto para evitar que hayan posible problemas en la unificación de categorias escritas de diferentes formas. 

Por lo tanto nos quedamos con las variables `Tipo`, `Estado`, `Aportacion_Beneficiario`, `Principio_Activo`, `PVP`, `Tratamiento_Larga_Duracion`, `Enfermedad` y `Codigo_Agrupacion`. También nos quedamos con las variables creadas `Tipo`, `Codigo_Laboratorio`, `tram_PVP`, `tram_presentacion` y `Sociedad`.

```{r}
cols <- c("Tipo", "Codigo_Laboratorio", "Estado", "Baja", "Aportacion_Beneficiario", "Principio_Activo", "PVP", "tram_PVP", "Tratamiento_Larga_Duracion", "Enfermedad", "tram_presentacion", "Sociedad", "Codigo_Agrupacion")

datos_sel <- datos[, cols]
```

## 5.3 Imputación de variables

En este apartado no deberemos imputar nada debido a que las variables seleccionadas a imputar numéricas han sido descartadas para los posteriores análisis ya que cogemos la variable informada PVP. Por lo que hace a las variables categóricas se le asigna los siguientes valores: 

```{r}

```


## 5.5 Normalidad de las variales

## 5.6 Detección de outliers

# 6. Contrastes
## 6.1 Precio vs. Tipo de Medicamento
## 6.2 Precio vs. Laboratorio
## 6.3 Precio vs. Enfermedad


# 7. Predicciones
## 7.1 Regressión lineal
```{r}
# A continuación generamos nuestro modelo lineal. Para ello primero de todo vamos a hacer los pasos de stepwise para que se escojan automaticamente aquellas variables que sean importantes para el modelo. 
library(MASS)

cols <- c("tram_PVP", "Codigo_Agrupacion")
dataRegresion <- datos_sel[, which(!colnames(datos_sel) %in% cols)]

full.model <- lm(PVP ~ ., data = dataRegresion)
step.model <- stepAIC(full.model, direction = "both", trace = FALSE)

summary(step.model)

```

## 7.2 Agrupación de medicamentos (clúster)

A continuación vamos a clasificar nuestros datos a través de un modelo de agrupación jerárquico como són los clústers. Los métodos jerárquicos aplican una descomposición jerárquica del conjunto de datos origen. A partir del conjunto de datos por separado, va agrupando los grupos similares hasta formar un único grupo. Lo bueno de este tipo de modelos es que se puede visualizar el árbol que se genera al formar los grupos y decidir el número de clases en las que se quiere partir los datos.

```{r}
# install.packages("magrittr")
# install.packages("dendextend")
# install.packages("dendextendRcpp")

library(dendextend)
library(magrittr)
library(cluster)

datos_cluster <- datos_sel[, which(!colnames(datos_sel) %in% c('PVP'))]

for(i in colnames(datos_cluster)){
  datos_cluster[, i] <- as.factor(datos_cluster[, i])
}

dend <- datos_sel %>% daisy(metric = "gower", stand=TRUE) %>% hclust(method = "ward.D") %>% as.dendrogram

labels(dend) <- rep(NA,nrow(datos_sel))
dend %>% color_branches(k=3,col=2:4) %>% plot(horiz=FALSE, main = "Método de Ward: 3 clusters",
                                              xlab='Participantes',ylab='Distancias') 
legend('topright',legend=c('Cluster 1','Cluster 2','Cluster 3'), lty=rep(1,3), col=c(2,3,4),cex=0.7)

abline(h = 30, lwd = 2, lty = 2, col = "blue")

c1 <- cutree(dend, 3)
datos_sel$CLUST3 <- as.factor(c1)
```


Como podemos ver en nuestro clúster, utilizamos la distancia de Gower ya que es aquella distancia que nos permite trabajar con variables de tipo categóricas. También se le aplica el método de Ward. El método de Ward es aquel que nos permite asegurar mínima variancia entre los grupos que se van formando. 

En el gráfico podemos ver como podriamos formar tanto 3 como 7 clases. El propósito era poder encontrar patrones de semejanza entre conjuntos de medicamentos y bajo una decisión experta, hemos decidido avanzar con el clúster de 3 clases. 

A continuación se muestra una descriptiva de las clases para las variables que hemos escogido. 

```{r}

```


## 7.3 Detección de patrones en las características (ACM)

Para acabar el tema de los modelos supervisados y no supervisados, hemos decidido generar un modelo de análisis de correspondencias múltiples (ACM). El análisis de correspondéncias múltiples (ACM) se trata de un método destinado a variables nominales que se utiliza para detectar y representar patrones escondidos en los datos. 

La forma de proceder es la siguiente, se representa los datos como puntos en un espacio euclídeo de dimensión 2. La forma de proyección es la misma que se utilizaria para la creación de los ACP (Análisis de componentes princiales) peró con variables que tienen más de dos niveles en sus categorias. 

Por lo tanto esta forma de detectar patrones es muy eficaz para nuestro conjunto de datos ya que, como se han explicado en apartados anteriores, nuestros datos estan compuestos por variables categóricas y una variable numérica. 

```{r}
# install.packages("ade4", dep = TRUE)
library(ade4)

# Creamos los datos para el ACM descartando la variable numérica
datosACM <- datos_sel[, which(!colnames(datos_sel) %in% c('PVP', 'Codigo_Laboratorio', 'Codigo_Agrupacion', 'Principio_Activo'))]

for(i in colnames(datosACM)){
  datosACM[, i] <- as.factor(datosACM[, i])
}

# Generamos el modelo ACM
acm <- dudi.acm(datosACM)

# Mostramos los gráficos
print(summary(acm))

```
Hemos tenido que descartar algunas de las variables debido al gran volumen de categorias que tenian esas variables. De aquí deberemos extraer una de las posibles mejoras del trabajo que seria el hecho de agrupar mejor categorias ya que con tantas categorias, el ACM no es comprensible visualmente. 

Teniendo en cuenta las limitaciones anteriores, vamos a interpretar tanto la salida de la inercia que contienen nuestros datos como la visualización de las categorias. 

Por lo que hace la salida del resumen de la inercia, vemos como sólo podemos explicar el 17.32% de la variancia de las categorias con tan solo dos dimensiones. Esto lo que nos permite identificar es que necesitamos más dimensiones para poder explicar la variancia de los datos. Por lo tanto aunque explicaremos dos dimensiones no seremos capaces de identificar todos los posibles patrones subyacentes que hay entre categorias de variables. 

```{r}
# Generamos el gráfico de aportación de cada variable al primer y al segundo eje
par(mfrow = c(2, 2))
for (i in 1:2) barplot(acm$cr[, i], names.arg = row.names(acm$cr), 
  las = 2, main = paste("Eje", i))
par(mfrow = c(1, 1))
```


Como podemos ver, la variable `Enfermedad`, es una variable que explica muy bien tanto la primera como la segunda dimension. Este hecho nos puede hacer pensar que es lo que nos pueden explicar los ejes. Viendo el histograma primero, vemos que para la primera dimension las variables `Enfermedad`, `tram_presentacion` y `Sociedad` son las mas representativas. Por lo tanto podriamos definir que el primer eje habla de la forma de tratamiento de los medicamentos para las empresas. El segundo eje lo podriamos definir como los medicamentos y los pacientes. 

Definición de los ejes: 
  - 1r eje: Medicamentos y laboratorios
  - 2n eje: Medicamentos y pacientes

A continuación realizamos el gráfico. 

```{r}
# Generamos el gráfico de proyección de ACM
s.label(acm$co, clabel = 0.6, boxes = FALSE)
```

Aunque el gráfico no es del todo aclarador debido a que hay muchas categorias que solapan algunas etiquetas, podemos distingir que:

- Medicamentos que sirven para tratar la diabetes se suelen dispensar en formato cartuchos, plumas o en bote. Este hecho nos hace pensar que igual las categorias cartuchos y plumas se podria unificar en una misma categoria por tal de evitar solapamientos. 

- Vemos como que la mayoria de los medicamentos de tratamiento de larga duración suelen tener como condicion de pago ESPECIAL. Significa que si tienes un tratamiento de larga duración tendrás tratamientos que estarán subvencionados por el estado y por lo tanto tendrás como definido que tu aportación al medicamento sea de tipo ESPECIAL. 


Mediante el paquete `explor` de R permite a través de un shiny realizar el estudio ACM al completo. 

# 8. Futuras lineas de trabajo

A continuación se detallarán futuras lineas de trabajo que se podrian realizar a partir de los datos que se han analizado. Decir que estas futuras lineas de trabajo se deberian de adecuar a las necesidades de cada usuario de los datos por lo tanto puede ser que para según quien use estos datos no le hagan falta algunas de las propuestas que se utilizarán a continuación:

  - Generar, a partir del modelo predictivo del árbol de decisión, un app que le permita a cualquier usuario médico encontrar rápidamente el medicamento mas adecuado para cada paciente.
  - Realizaría más text mining a la variable Medicamento e Presentación para extraer más características de los productos que no se han extraido ni se han podido extraer.
  -
  -
  - 

# 9. Código

El código del proyecto se encuentra en el repositorio libre de Github. [Enlace](https://github.com/lmgeraldino/vademecum-consolidation).

  
